# 1.4. CLI Foundation (`internal/cli`)

**Goal**: Establish a robust CLI architecture using `cobra` that supports dependency injection (DI) for testability and consistent error handling (`RunE`).

## 1. References & Context
*   **PRD**: [CLI Commands](../PRD.md#32-cli-commands)
*   **Libraries**:
    *   [spf13/cobra](https://github.com/spf13/cobra): CLI framework.
*   **Best Practices**:
    *   **DI**: Inject dependencies (Store, Config) via constructors (`NewRootCmd(store)`), avoiding global state.
    *   **Error Handling**: Use `RunE` instead of `Run` to propagate errors to the root.
    *   **Signal Handling**: Graceful shutdown for TUI/Executors.

## 2. Detailed Steps

### A. Root Command (`cmd/kevin/main.go`)
The `main` function should be the **Composition Root**. It initializes dependencies and injects them.

```go
func main() {
    // 1. Load Config
    cfg, err := core.LoadConfig()
    if err != nil { ... }

    // 2. Init Store
    store, err := store.NewFileStore(cfg.DataDir)
    if err != nil { ... }

    // 3. Init Root Cmd (Dependency Injection)
    rootCmd := cli.NewRootCmd(cfg, store)

    // 4. Execute
    if err := rootCmd.Execute(); err != nil {
        os.Exit(1) // Only exit in main
    }
}
```

### B. Command Structure (`internal/cli/root.go`)
Define a struct to hold dependencies for subcommands.

```go
type CLI struct {
    Config *core.ProjectConfig
    Store  store.Store
}

func NewRootCmd(cfg *core.ProjectConfig, s store.Store) *cobra.Command {
    app := &CLI{Config: cfg, Store: s}
    
    cmd := &cobra.Command{
        Use:          "kevin",
        Short:        "The Helpful Agent Orchestrator",
        SilenceUsage: true, // Don't show help on runtime errors
    }

    // Add Subcommands
    cmd.AddCommand(app.newInitCmd())
    cmd.AddCommand(app.newTaskCmd())

    return cmd
}
```

### C. Init Command (`internal/cli/init.go`)
Logic to bootstrap the project.

```go
func (app *CLI) newInitCmd() *cobra.Command {
    return &cobra.Command{
        Use:   "init",
        Short: "Initialize a new Kevin project",
        RunE: func(cmd *cobra.Command, args []string) error {
            // Check if .kevin exists
            // Create directories
            // Write default config
            return nil
        },
    }
}
```

### D. Task Command (`internal/cli/task.go`)
Example of using the injected `Store`.

```go
func (app *CLI) newTaskCmd() *cobra.Command {
    cmd := &cobra.Command{
        Use:   "task",
        Short: "Manage tasks",
    }
    
    // Subcommand: New
    cmd.AddCommand(&cobra.Command{
        Use:   "new [title]",
        Short: "Create a new task",
        Args:  cobra.ExactArgs(1),
        RunE: func(c *cobra.Command, args []string) error {
            task := core.NewTask(args[0])
            return app.Store.Create(task) // Use injected store
        },
    })
    
    return cmd
}
```

## 3. Success Criteria
- [ ] `main.go` performs dependency injection.
- [ ] `CLI` struct holds `Store` and `Config`.
- [ ] `kevin init` creates `.kevin/` and `config.yaml`.
- [ ] `kevin task new "Hello"` creates a markdown file via the Store.
- [ ] `RunE` is used everywhere; errors bubble up to `main`.
