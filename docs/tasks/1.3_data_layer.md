# 1.3. Data Layer (`internal/store`)

**Goal**: Implement the `FileStore` which serves as the "Reactive Database" for Kevin. It must watch the `.kevin/board/` directory and broadcast updates when files change.

## 1. References & Context
*   **PRD**: [Data Layer](../PRD.md#34-data-layer--persistence)
*   **Libraries**:
    *   [fsnotify/fsnotify](https://github.com/fsnotify/fsnotify): For cross-platform file watching.
    *   [adrg/frontmatter](https://github.com/adrg/frontmatter): For parsing.
*   **Concepts**:
    *   **Debounce**: Collect rapid bursts of events (e.g., `CREATE` + `WRITE` + `CHMOD`) into a single update.
    *   **Reaction Time**: Target < 200ms form save to UI update.
    *   **Recursive Watching**: `fsnotify` is non-recursive by default. We must walk directories if we support sub-folders (MVP only supports flat `.kevin/board/`).

## 2. Detailed Steps

### A. Store Interface (`internal/store/interface.go`)
Define the contract.

```go
package store

import "github.com/rtfa/kevin/internal/core"

type Store interface {
    // CRUD
    List() ([]core.Task, error)
    Get(id string) (core.Task, error)
    Create(task core.Task) error
    Update(task core.Task) error

    // Reactivity
    Watch() <-chan TaskUpdateEvent
}

type TaskUpdateEvent struct {
    TaskID string
    Type   EventType // Created, Updated, Deleted
}
```

### B. FileStore Struct (`internal/store/filestore.go`)
Implement the struct.

```go
type FileStore struct {
    dir     string
    watcher *fsnotify.Watcher
    updates chan TaskUpdateEvent
}
```

### C. The Watch Loop & Debounce
Implement the `StartWatching` logic with a debounce timer.
**Pattern**:
1.  On Event -> Check if Timer is running.
2.  If running -> Stop/Reset.
3.  If not running -> Start Timer (e.g., 100ms).
4.  On Timer Fire -> Parse the file -> Send `TaskUpdateEvent`.

```go
func (s *FileStore) watchLoop() {
    var debounceTimer *time.Timer
    const debounceDuration = 100 * time.Millisecond

    for {
        select {
        case event, ok := <-s.watcher.Events:
            if !ok { return }
            // Ignore temporary files (vim swap, ds_store)
            if isIgnored(event.Name) { continue }

            // Debounce logic
            if debounceTimer != nil {
                debounceTimer.Stop()
            }
            debounceTimer = time.AfterFunc(debounceDuration, func() {
                 s.handleFileChange(event.Name)
            })

        case err, ok := <-s.watcher.Errors:
             // log error
        }
    }
}
```

### D. Parsing Logic
*   Read file content.
*   Use `frontmatter.Parse(reader, &task)`.
*   Assign `task.Body` from the remaining content.
*   Assign `task.FilePath` from the path.

## 3. Success Criteria
- [ ] `FileStore` implements `Store` interface.
- [ ] `List()` returns tasks from `.kevin/board/*.md`.
- [ ] `fsnotify` loop is running in a goroutine.
- [ ] Editing a file in VSCode triggers an event on `Watch()` channel (visible via log).
- [ ] Debounce prevents double-firing on atomic saves.
